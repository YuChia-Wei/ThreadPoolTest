# 性能比較報告：CPU 核心數提升影響

## 測試報告概述

本報告旨在比較 `ThreadsPoolTest.DotnetControl` API 在不同 CPU 核心數配置下的性能表現。

*   **測試目標 API**: `ThreadsPoolTest.DotnetControl` (使用 .NET Runtime 自行控制 Thread Pool 的版本)
*   **API 執行資源**: 4GB 記憶體，CPU 核心數從 2 提升到 4。
*   **網路控制**: 無

## 關鍵指標比較

| 指標                      | 2 核心 CPU & 4GB 記憶體 (原結果) | 4 核心 CPU & 4GB 記憶體 (新結果) | 變化 (新 - 舊) |
| :------------------------ | :------------------------------- | :------------------------------- | :------------- |
| **`http_req_duration` (p95)** | 26.3 秒                          | 27.91 秒                         | +1.61 秒       |
| **`http_req_duration` (avg)** | 9.92 秒                          | 10.48 秒                         | +0.56 秒       |
| **`http_req_failed` (rate)**  | 0.13% (9 次失敗)                 | 0.14% (9 次失敗)                 | +0.01%         |
| **總請求數**              | 6584                             | 6295                             | -289           |
| **總運行時間**            | 5 分 38.1 秒                     | 5 分 39.8 秒                     | +1.7 秒        |
| **發送數據量**            | 35 GB (102 MB/s)                 | 33 GB (97 MB/s)                  | -2 GB (-5 MB/s) |

## 分析與結論

從比較結果來看，將 CPU 核心數從 2 提升到 4，對於 `ThreadsPoolTest.DotnetControl` API 的性能**沒有帶來預期的改善，反而略有退步**。

*   **響應時間惡化**：`p(95)` 和 `avg` 的 `http_req_duration` 在提升 CPU 核心數後反而略微增加。這意味著 95% 的請求響應時間從 26.3 秒增加到 27.91 秒，平均響應時間也從 9.92 秒增加到 10.48 秒。
*   **失敗率和總請求數變化不大**：失敗率幾乎沒有變化，總請求數甚至略有下降。
*   **數據發送量略有減少**：這可能與總請求數的輕微下降有關。

**推論：**

這個結果強烈支持了之前的推論：**性能瓶頸不在 CPU 核心數不足，而是在於應用程式內部的其他因素。**

如果 CPU 是瓶頸，那麼增加 CPU 核心數應該會顯著改善響應時間和吞吐量。然而，我們觀察到的情況是性能不升反降，這可能暗示：

1.  **同步阻塞操作仍然是主要瓶頸**：如果應用程式中存在大量的同步 I/O 操作、鎖競爭或其他阻塞執行緒的程式碼，那麼即使有更多的 CPU 核心，這些執行緒仍然會被阻塞，無法充分利用額外的 CPU 資源。
2.  **上下文切換開銷增加**：在某些情況下，如果應用程式沒有被設計為有效利用多核心，或者存在過多的執行緒競爭，增加核心數反而可能導致更多的上下文切換開銷，進而影響性能。
3.  **其他資源瓶頸**：例如記憶體頻繁的垃圾回收、磁碟 I/O 速度、或數據庫響應時間等，這些瓶頸可能比 CPU 更為突出，導致即使 CPU 資源充足，整體性能也無法提升。

## 建議

基於此結果，**增加 CPU 核心數並不是解決當前性能問題的有效方法**。您應該將重點放在：

1.  **深入的程式碼級別性能分析**：
    *   **定位同步阻塞**：使用性能分析工具（如 Visual Studio Profiler, dotTrace, PerfView）精確定位程式碼中所有同步阻塞 I/O 操作、`Task.Wait()` 或 `Task.Result` 的使用。
    *   **分析鎖競爭**：檢查程式碼中是否存在對共享資源的過度鎖定或低效鎖定，導致執行緒長時間等待。
    *   **GC 分析**：監控 GC 相關指標，檢查是否存在頻繁的垃圾回收導致應用程式暫停。
2.  **優化 I/O 操作**：確保所有檔案讀寫操作都使用異步模式，並優化檔案流處理。
3.  **檢查中介軟體**：重新審視請求管道中的中介軟體，確保它們沒有引入不必要的同步或耗時操作。
4.  **數據庫/外部服務**：如果 API 依賴外部服務，檢查這些服務的性能是否是瓶頸。

總之，在解決應用程式內部的根本性性能瓶頸之前，單純的硬體升級（如增加 CPU 核心數）很難帶來顯著的性能改善。