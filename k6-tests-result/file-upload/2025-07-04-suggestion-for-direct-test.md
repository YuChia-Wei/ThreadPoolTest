# 綜合性能評估與建議報告 (無網路控制測試)

## 測試報告概述

本報告旨在綜合分析兩份在**移除網路控制**後進行的 k6 性能測試報告：

1.  **`k6-result-runtime-set-thread-pool.txt`**：測試目標為使用 .NET Runtime 預設控制 Thread Pool 的 API 版本 (`ThreadsPoolTest.DotnetControl`)。
2.  **`k6-result-preset-thread-pool.txt`**：測試目標為已預先設定最小執行緒數的 API 版本 (`ThreadsPoolTest.SetMinThreadsPool`)。

兩者均在 2 核心 CPU & 4GB 記憶體的資源配置下進行測試。

## 關鍵指標比較

| 指標                      | `ThreadsPoolTest.DotnetControl` (預設控制) | `ThreadsPoolTest.SetMinThreadsPool` (預設最小執行緒數) |
| :------------------------ | :--------------------------------------- | :------------------------------------------------- |
| **`http_req_duration` (p95)** | 26.3 秒                                  | 15.58 秒                                           |
| **`http_req_duration` (avg)** | 9.92 秒                                  | 9.79 秒                                            |
| **`http_req_failed` (rate)**  | 0.13% (9 次失敗)                         | 0.00% (0 次失敗)                                   |
| **總請求數**              | 6584                                     | 6592                                               |
| **測試時間**              | 5 分 38.1 秒                             | 5 分 31.1 秒                                       |

## 綜合評估

從兩份移除網路控制後的報告比較中，我們可以得出以下結論：

1.  **響應時間仍是主要瓶頸**：
    *   `ThreadsPoolTest.DotnetControl` 的 p95 響應時間為 26.3 秒。
    *   `ThreadsPoolTest.SetMinThreadsPool` 的 p95 響應時間為 15.58 秒。
    兩者都遠遠未能達到 3 秒的閾值。這表明即使移除了網路限制，API 在高併發場景下的響應速度仍然非常慢，嚴重影響用戶體驗。網路並非唯一的瓶頸。

2.  **預設最小執行緒數版本表現更優**：
    *   `ThreadsPoolTest.SetMinThreadsPool` 在 p95 響應時間上顯著優於 `ThreadsPoolTest.DotnetControl` (15.58s vs 26.3s)。
    *   `ThreadsPoolTest.SetMinThreadsPool` 的失敗率為 0.00%，而 `ThreadsPoolTest.DotnetControl` 為 0.13%。
    這再次證明了預先設定較高的最小執行緒數對於穩定性和響應時間的正面影響，尤其是在沒有網路限制的情況下，其優勢更加明顯。

3.  **內部瓶頸顯現**：由於移除了網路控制，但響應時間仍然很高，這強烈暗示性能瓶頸主要存在於應用程序內部，而非網路層面。這可能與 CPU 處理能力、記憶體管理、I/O 操作效率或應用程序代碼邏輯有關。

## 建議

基於上述評估，以下是針對兩種寫法在移除網路控制後的綜合建議：

1.  **聚焦應用程序內部性能分析 (核心)**：
    *   **CPU 使用率**：使用 `dotnet-counters` 或其他性能監控工具，在高負載測試期間監控 API 的 CPU 使用率。判斷是否存在 CPU 密集型操作導致瓶頸。考慮使用 CPU 分析工具 (如 PerfView) 深入分析熱點代碼。
    *   **記憶體使用與 GC**：監控記憶體消耗，檢查是否存在記憶體洩漏或頻繁的垃圾回收 (GC) 導致應用程序停頓。優化記憶體分配和對象生命週期。
    *   **I/O 操作效率**：由於是檔案上傳，重點檢查磁盤 I/O 性能。確認檔案寫入速度是否是瓶頸，以及是否有高效的緩衝區管理。考慮使用異步 I/O 操作以避免阻塞執行緒。
    *   **數據庫/外部服務**：如果 API 依賴數據庫或其他外部服務，檢查這些服務的響應時間和連接池使用情況。確認它們是否成為瓶頸，並考慮優化數據庫查詢或引入緩存機制。
    *   **鎖競爭/同步**：分析代碼中是否存在過多的鎖競爭或不必要的同步操作，導致執行緒阻塞和性能下降。考慮使用無鎖數據結構或更細粒度的鎖。

2.  **代碼層面深度優化**：
    *   **異步編程模型**：確保所有 I/O 密集型操作都採用異步 (async/await) 模式，避免阻塞執行緒池中的執行緒。檢查是否有同步阻塞的代碼段。
    *   **數據流處理**：優化檔案處理邏輯，例如使用流式處理 (streaming) 而不是一次性讀取整個檔案到記憶體，減少記憶體壓力。
    *   **算法和數據結構**：審查核心業務邏輯中使用的算法和數據結構，確保其在高併發下仍能高效運行。例如，避免在熱點路徑上使用低效的集合操作。

3.  **執行緒池配置的精細調整**：
    *   雖然 `SetMinThreadsPool` 表現更好，但仍可嘗試在 `ThreadsPoolTest.SetMinThreadsPool` 專案中，根據實際的 CPU 核心數和 I/O 特性，精細調整 `ThreadPool.SetMinThreads` 和 `ThreadPool.SetMaxThreads` 的值，找到最佳平衡點。但這應在內部瓶頸分析後進行。

4.  **資源擴展評估 (最後手段)**：
    *   在完成所有可能的軟體層面優化和瓶頸分析後，如果性能仍未達標，則才考慮增加 API 服務器的 CPU 核心數或記憶體。硬體擴展應作為解決方案的最後一步。

5.  **持續監控與基準測試**：
    *   在開發和部署過程中，應建立持續的性能監控機制，並定期進行基準測試，以便及時發現和解決性能回歸問題。特別是針對優化後的版本，需要進行新的基準測試來驗證效果。

**總結**：

移除網路控制後的測試結果進一步證實，`ThreadsPoolTest.SetMinThreadsPool` 在性能上優於 `ThreadsPoolTest.DotnetControl`。然而，兩者都未能達到理想的響應時間。這表明核心瓶頸在於應用程序本身的處理效率。當務之急是進行深入的應用程序內部性能分析和代碼優化，以解決根本問題。