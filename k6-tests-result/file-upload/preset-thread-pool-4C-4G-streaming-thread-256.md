# 性能比較報告：最小執行緒數 128 vs 256 (Streaming, 4C-4G)

## 測試報告概述

本報告旨在比較 `ThreadsPoolTest.SetMinThreadsPool` API 在 4 核心 CPU & 4GB 記憶體、使用 Streaming 方式上傳檔案的配置下，不同最小執行緒池大小 (128 vs 256) 對性能的影響。

*   **測試目標 API**: `ThreadsPoolTest.SetMinThreadsPool` (已預先設定最小執行緒數的 API 版本，使用 Streaming)
*   **API 執行資源**: 4 核心 CPU & 4GB 記憶體
*   **網路控制**: 無

## 關鍵指標比較

| 指標                      | 最小執行緒數 128 (原結果) | 最小執行緒數 256 (新結果) | 變化 (新 - 舊) |
| :------------------------ | :------------------------ | :------------------------ | :------------- |
| **`http_req_duration` (p95)** | 27.81 秒                  | 27.43 秒                  | -0.38 秒       |
| **`http_req_duration` (avg)** | 10.14 秒                  | 9.95 秒                   | -0.19 秒       |
| **`http_req_failed` (rate)**  | 0.07% (5 次失敗)          | 0.04% (3 次失敗)          | -0.03%         |
| **總請求數**              | 6542                      | 6674                      | +132           |
| **總運行時間**            | 5 分 43.3 秒              | 5 分 40.9 秒              | -2.4 秒        |
| **發送數據量**            | 34 GB (100 MB/s)          | 35 GB (103 MB/s)          | +1 GB (+3 MB/s) |

## 分析與結論

從比較結果來看，將最小執行緒池大小從 128 提升到 256，對於 `ThreadsPoolTest.SetMinThreadsPool` API 的性能帶來了**輕微的正面改善**。

*   **響應時間略有改善**：`p(95)` 的 `http_req_duration` 從 27.81 秒輕微下降到 27.43 秒。平均響應時間也略有下降。
*   **失敗率略有降低**：從 0.07% 下降到 0.04%，表明穩定性略有提升。
*   **總請求數和數據發送量略有增加**：這表明吞吐量有輕微提升。

**推論：**

雖然改善幅度不大，但這個結果表明：

1.  **增加最小執行緒數對性能有正面影響**：這與 `SetMinThreadsPool` 專案的設計初衷一致，即預先設定較高的最小執行緒數有助於減少執行緒池動態擴展的開銷，從而輕微改善響應時間和吞吐量。
2.  **根本瓶頸仍然存在**：儘管有輕微改善，但 `p(95)` 響應時間仍然高達 27.43 秒，遠遠超過 3 秒的閾值。這再次證明了應用程式內部存在更深層次的性能瓶頸，這些瓶頸並非單純增加執行緒數就能解決。

## 綜合建議：

這個測試結果支持了 `SetMinThreadsPool` 的概念，即預設較高的最小執行緒數在一定程度上是有益的。然而，它也再次強調了**應用程式內部存在更嚴重的性能瓶頸**。

您應該繼續將重點放在：

1.  **深入的程式碼級別性能分析 (最優先)**：
    *   **分析鎖競爭**：這是最可疑的原因。使用性能分析工具（如 Visual Studio Profiler, dotTrace, PerfView）精確定位程式碼中所有對共享資源的鎖定 (`lock` 語句, `SemaphoreSlim`, `Mutex` 等)。分析這些鎖的粒度、頻率和競爭情況。
    *   **定位同步阻塞**：再次確認程式碼中所有同步阻塞 I/O 操作、`Task.Wait()` 或 `Task.Result` 的使用。
    *   **GC 分析**：監控 GC 相關指標，檢查是否存在頻繁的垃圾回收導致應用程式暫停。
2.  **優化併發控制**：
    *   如果存在鎖競爭，考慮使用更細粒度的鎖，或者使用無鎖 (lock-free) 的數據結構和算法。
    *   重新設計共享資源的訪問模式，減少競爭。
3.  **優化 I/O 操作**：確保所有檔案讀寫操作都使用異步模式，並優化檔案流處理。
4.  **檢查中介軟體**：重新審視請求管道中的中介軟體，確保它們沒有引入不必要的同步或耗時操作。
5.  **數據庫/外部服務**：如果 API 依賴外部服務，檢查這些服務的性能是否是瓶頸。

總之，雖然增加最小執行緒數帶來了輕微的正面影響，但這並非解決根本性能問題的關鍵。您需要更深入地分析應用程式內部的瓶頸，特別是鎖競爭和同步阻塞，才能實現顯著的性能提升。