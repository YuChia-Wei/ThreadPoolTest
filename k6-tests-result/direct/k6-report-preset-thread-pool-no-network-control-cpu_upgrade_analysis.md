# 性能比較報告：CPU 核心數提升影響 (預設最小執行緒數版本)

## 測試報告概述

本報告旨在比較 `ThreadsPoolTest.SetMinThreadsPool` API 在不同 CPU 核心數配置下的性能表現。

*   **測試目標 API**: `ThreadsPoolTest.SetMinThreadsPool` (已預先設定最小執行緒數的 API 版本)
*   **API 執行資源**: 4GB 記憶體，CPU 核心數從 2 提升到 4。
*   **網路控制**: 無

## 關鍵指標比較

| 指標                      | 2 核心 CPU & 4GB 記憶體 (原結果) | 4 核心 CPU & 4GB 記憶體 (新結果) | 變化 (新 - 舊) |
| :------------------------ | :------------------------------- | :------------------------------- | :------------- |
| **`http_req_duration` (p95)** | 15.58 秒                         | 27.52 秒                         | +11.94 秒      |
| **`http_req_duration` (avg)** | 9.79 秒                          | 9.97 秒                          | +0.18 秒       |
| **`http_req_failed` (rate)**  | 0.00% (0 次失敗)                 | 0.16% (11 次失敗)                | +0.16%         |
| **總請求數**              | 6592                             | 6566                             | -26            |
| **總運行時間**            | 5 分 31.1 秒                     | 5 分 38.3 秒                     | +7.2 秒        |
| **發送數據量**            | 35 GB (104 MB/s)                 | 34 GB (102 MB/s)                 | -1 GB (-2 MB/s) |

## 分析與結論

從比較結果來看，將 CPU 核心數從 2 提升到 4，對於 `ThreadsPoolTest.SetMinThreadsPool` API 的性能**沒有帶來預期的改善，反而出現了顯著的惡化**。

*   **響應時間顯著惡化**：`p(95)` 的 `http_req_duration` 從 15.58 秒急劇增加到 27.52 秒，這是一個非常大的退步。平均響應時間也略有增加。
*   **失敗率增加**：從 0.00% 增加到 0.16%，雖然絕對值不高，但從零失敗到有失敗，表明穩定性有所下降。
*   **總請求數和數據發送量變化不大**：這表明吞吐量沒有顯著提升。

**推論：**

這個結果進一步強化了之前的推論：**性能瓶頸不在 CPU 核心數不足，而是在於應用程式內部的其他因素，並且這些因素在多核心環境下可能被放大。**

*   **同步阻塞操作仍然是主要瓶頸**：如果應用程式中存在大量的同步 I/O 操作、鎖競爭或其他阻塞執行緒的程式碼，那麼即使有更多的 CPU 核心，這些執行緒仍然會被阻塞。
*   **鎖競爭或同步開銷被放大**：在多核心環境下，如果程式碼中存在對共享資源的競爭，增加核心數可能會導致更多的執行緒同時嘗試獲取鎖，從而加劇鎖競爭，導致更多的執行緒等待，進而降低整體性能。這可能是 `p(95)` 響應時間急劇惡化的主要原因。
*   **上下文切換開銷**：更多的核心和潛在的更多執行緒競爭可能導致更高的上下文切換開銷。
*   **記憶體或 I/O 瓶頸**：如果底層的記憶體或磁碟 I/O 速度是瓶頸，那麼增加 CPU 核心數也無濟於事，反而可能因為更多的執行緒同時請求這些慢速資源而導致排隊加劇。

## 建議

基於此結果，**增加 CPU 核心數並不是解決當前性能問題的有效方法，反而可能使問題惡化**。您應該將重點放在：

1.  **深入的程式碼級別性能分析 (最優先)**：
    *   **分析鎖競爭**：這是最可疑的原因。使用性能分析工具（如 Visual Studio Profiler, dotTrace, PerfView）精確定位程式碼中所有對共享資源的鎖定 (`lock` 語句, `SemaphoreSlim`, `Mutex` 等)。分析這些鎖的粒度、頻率和競爭情況。
    *   **定位同步阻塞**：再次確認程式碼中所有同步阻塞 I/O 操作、`Task.Wait()` 或 `Task.Result` 的使用。
    *   **GC 分析**：監控 GC 相關指標，檢查是否存在頻繁的垃圾回收導致應用程式暫停。
2.  **優化併發控制**：
    *   如果存在鎖競爭，考慮使用更細粒度的鎖，或者使用無鎖 (lock-free) 的數據結構和算法。
    *   重新設計共享資源的訪問模式，減少競爭。
3.  **優化 I/O 操作**：確保所有檔案讀寫操作都使用異步模式，並優化檔案流處理。
4.  **檢查中介軟體**：重新審視請求管道中的中介軟體，確保它們沒有引入不必要的同步或耗時操作。
5.  **數據庫/外部服務**：如果 API 依賴外部服務，檢查這些服務的性能是否是瓶頸。

總之，在解決應用程式內部的根本性性能瓶頸（特別是鎖競爭和同步阻塞）之前，單純的硬體升級（如增加 CPU 核心數）不僅無法帶來顯著的性能改善，反而可能因為加劇內部競爭而導致性能下降。