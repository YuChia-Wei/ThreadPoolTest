# 綜合性能評估與建議報告

## 測試報告概述

本報告旨在綜合分析兩份 k6 性能測試報告：

1.  **`k6-report-dotnet-runtime-control-2core-4GB-202507041113336.md`**：測試目標為使用 .NET Runtime 預設控制 Thread Pool 的 API 版本 (`ThreadsPoolTest.DotnetControl`)。
2.  **`k6-report-dotnet-preset-control-2core-4GB-20250704132835.md`**：測試目標為已預先設定最小執行緒數的 API 版本 (`ThreadsPoolTest.SetMinThreadsPool`)。

兩者均在 2 核心 CPU & 4GB 記憶體的資源配置下進行測試。

## 關鍵指標比較

| 指標                      | `ThreadsPoolTest.DotnetControl` (預設控制) | `ThreadsPoolTest.SetMinThreadsPool` (預設最小執行緒數) |
| :------------------------ | :--------------------------------------- | :------------------------------------------------- |
| **`http_req_duration` (p95)** | 27.72 秒                                 | 16.16 秒                                           |
| **`http_req_duration` (avg)** | 10.03 秒                                 | 9.95 秒                                            |
| **`http_req_failed` (rate)**  | 0.07% (5 次失敗)                         | 0.00% (0 次失敗)                                   |
| **總請求數**              | 6422                                     | 6494                                               |
| **測試時間**              | 5 分 31.7 秒                             | 5 分 33.4 秒                                       |

## 綜合評估

從兩份報告的比較中，我們可以得出以下結論：

1.  **響應時間仍是主要瓶頸**：儘管 `ThreadsPoolTest.SetMinThreadsPool` 在 95% 請求響應時間 (p95) 上有所改善 (從 27.72 秒降至 16.16 秒)，但兩者都遠遠未能達到 3 秒的閾值。這表明無論是預設執行緒池還是預設最小執行緒數，API 在高併發場景下的響應速度都非常慢，嚴重影響用戶體驗。

2.  **預設最小執行緒數帶來輕微改善**：`ThreadsPoolTest.SetMinThreadsPool` 在失敗率上表現更好 (0% 失敗)，並且 p95 響應時間有所降低。這說明預先設定較高的最小執行緒數確實對穩定性和響應時間有正面影響，減少了執行緒池動態擴展帶來的延遲和潛在的請求失敗。

3.  **性能瓶頸不在執行緒池本身**：由於 `SetMinThreadsPool` 的優化未能將響應時間顯著降低到可接受的範圍，這強烈暗示性能瓶頸可能不在執行緒池的動態管理上，或者至少不完全是。這意味著需要將分析重點轉向應用程序內部的其他潛在瓶頸。

4.  **資源利用率可能存在問題**：在 2 核心 CPU 和 4GB 記憶體的環境下，如此高的響應時間和大量的數據發送 (34 GB) 卻未能達到預期性能，這可能意味著資源沒有被有效利用，或者存在其他資源限制。

## 建議

基於上述評估，以下是針對兩種寫法的綜合建議：

1.  **深入的性能瓶頸分析 (首要任務)**：
    *   **CPU 使用率**：使用 `dotnet-counters` 或其他性能監控工具，在高負載測試期間監控 API 的 CPU 使用率。判斷是否存在 CPU 密集型操作導致瓶頸。
    *   **記憶體使用**：監控記憶體消耗，檢查是否存在記憶體洩漏或頻繁的垃圾回收 (GC) 導致應用程序停頓。
    *   **I/O 操作**：由於是檔案上傳，重點檢查磁盤 I/O 性能和網絡帶寬。確認檔案寫入速度是否是瓶頸，以及網絡傳輸是否受限。
    *   **數據庫/外部服務**：如果 API 依賴數據庫或其他外部服務，檢查這些服務的響應時間和連接池使用情況。確認它們是否成為瓶頸。
    *   **鎖競爭/同步**：分析代碼中是否存在過多的鎖競爭或不必要的同步操作，導致線程阻塞和性能下降。

2.  **代碼層面優化**：
    *   **異步編程**：確保所有 I/O 密集型操作都採用異步 (async/await) 模式，避免阻塞執行緒池中的執行緒。
    *   **數據處理效率**：優化檔案處理邏輯，例如分塊讀取/寫入、使用緩衝區等，減少不必要的記憶體拷貝和處理時間。
    *   **算法和數據結構**：審查核心業務邏輯中使用的算法和數據結構，確保其在高併發下仍能高效運行。

3.  **執行緒池配置的進一步實驗**：
    *   雖然 `SetMinThreadsPool` 有所改善，但仍可嘗試調整 `ThreadPool.SetMinThreads` 和 `ThreadPool.SetMaxThreads` 的值，進行小範圍的實驗，觀察對性能的影響。但請記住，這可能不是根本解決方案。

4.  **資源擴展評估**：
    *   在完成代碼優化和瓶頸分析後，如果性能仍未達標，則需要考慮增加 API 服務器的 CPU 核心數或記憶體。但應在確定軟體層面已無明顯優化空間後再考慮硬體擴展。

5.  **持續監控與基準測試**：
    *   在開發和部署過程中，應建立持續的性能監控機制，並定期進行基準測試，以便及時發現和解決性能回歸問題。

**總結**：

目前來看，`ThreadsPoolTest.SetMinThreadsPool` 雖然略優於 `ThreadsPoolTest.DotnetControl`，但兩者都未能滿足性能要求。當務之急是進行深入的性能分析，找出真正的瓶頸所在，並針對性地進行代碼優化。單純調整執行緒池的配置可能無法解決根本問題。